
Setup
python -m venv venv
source venv/bin/activate  # Mac/Linux
pip install -r requirements.txt
Run Examples
python examples/design_patterns/creational/singleton.py
python examples/design_patterns/behavioral/observer.py
python examples/architecture/hexagonal/traffic_light_controller.py
Run Tests
pytest                                    # All tests
pytest tests/test_design_patterns.py -v  # Specific file
pytest --cov=examples                     # With coverage
ğŸ“‹ Design Patterns Cheat Sheet
Creational (When/Why to Use)
Pattern	When to Use	Example
Singleton	Need exactly one instance	Database connection, Logger
Factory	Donâ€™t know exact class at compile time	Document reader (PDF, Word, Excel)
Builder	Complex object construction	Building SQL queries, Config objects
Behavioral (When/Why to Use)
Pattern	When to Use	Example
Observer	One-to-many dependency notifications	Event system, MVC, Pub-Sub
Strategy	Multiple algorithms, runtime selection	Sorting, Compression, Validation
State	Object behavior changes with state	TCP connection, Order processing
Command	Parameterize, queue, or log operations	Undo/Redo, Macro recording, Job queue
Structural (When/Why to Use)
Pattern	When to Use	Example
Decorator	Add features without inheritance	Java I/O streams, UI components
Adapter	Make incompatible interfaces work	Legacy system integration
Facade	Simplify complex subsystem	Library wrapper, API simplification
ğŸ¯ Traffic Light Controller - Pattern Application
Problem: NatWest Coding Kata
â€¢Manage traffic light state for multiple directions
â€¢Prevent conflicting green lights
â€¢Accept commands (change, pause, resume)
â€¢Provide state and history
â€¢Thread-safe concurrency
Solution: Pattern Combinations
Architecture: Hexagonal (Ports & Adapters)
â”œâ”€â”€ Core Domain
â”‚   â”œâ”€â”€ TrafficLight (Entity)
â”‚   â”œâ”€â”€ Intersection (Aggregate)
â”‚   â””â”€â”€ ConflictValidator (Domain Service)
â”‚
â”œâ”€â”€ Patterns Used
â”‚   â”œâ”€â”€ Singleton: One controller per intersection
â”‚   â”œâ”€â”€ Factory: Create different light types
â”‚   â”œâ”€â”€ Observer: Notify monitoring systems
â”‚   â”œâ”€â”€ Strategy: Different sequencing algorithms
â”‚   â”œâ”€â”€ State: Light state machine (Redâ†’Yellowâ†’Green)
â”‚   â”œâ”€â”€ Command: Undo/redo operations
â”‚   â””â”€â”€ Decorator: Add logging, validation
â”‚
â””â”€â”€ Ports & Adapters
    â”œâ”€â”€ Ports (Interfaces)
    â”‚   â”œâ”€â”€ TrafficLightRepository
    â”‚   â””â”€â”€ EventPublisher
    â””â”€â”€ Adapters (Implementations)
        â”œâ”€â”€ InMemoryRepository
        â””â”€â”€ ConsoleEventPublisher
ğŸ§ª TDD Workflow
RED: Write failing test
   def test_no_conflicting_green():
       controller.set_green('NORTH')
       with pytest.raises(ConflictError):
           controller.set_green('EAST')

GREEN: Minimal code to pass
   def set_green(self, direction):
       if self._has_conflict(direction):
           raise ConflictError()
       self._state[direction] = 'GREEN'


 Concurrency Patterns
Problem: Race Conditions

if self.north_light == "RED":
    self.north_light = "GREEN"
Solution 1: Locks

with self._lock:
    if self.north_light == "RED":
        self.north_light = "GREEN"
Solution 2: Message Passing

command_queue.put(ChangeToGreenCommand('NORTH'))
ğŸ“ Architecture Decision Matrix
Scenario	Recommended Architecture	Why
Simple CRUD app	Layered	Easy to understand, sufficient
Complex business logic	Hexagonal	Testable, maintainable
Multiple teams	Microservices	Independent deployment
Growing monolith	Modular Monolith	Structure without complexity
ğŸ“ Learning Checklist
Week 1: Foundations
â€¢â˜ Read Lesson 1 (Architecture)
â€¢â˜ Understand Hexagonal Architecture
â€¢â˜ Run traffic light controller example
â€¢â˜ Complete Exercise 1
Week 2: Creational Patterns
â€¢â˜ Singleton pattern (thread-safe)
â€¢â˜ Factory Method pattern
â€¢â˜ Builder pattern
â€¢â˜ Run all creational examples
â€¢â˜ Write tests for Singleton
Week 3: Behavioral Patterns
â€¢â˜ Observer pattern
â€¢â˜ Strategy pattern
â€¢â˜ State pattern
â€¢â˜ Command pattern
â€¢â˜ Complete Observer exercise
Week 4: Integration
â€¢â˜ Combine multiple patterns
â€¢â˜ Implement complete traffic controller
â€¢â˜ Add concurrency safety
â€¢â˜ Achieve 80%+ test coverage
â€¢â˜ Handle all edge cases
ğŸ’¡ Common Mistakes & Solutions

class UserService(Singleton): pass
class OrderService(Singleton): pass
class ProductService(Singleton): pass

class OrderService:
    def __init__(self, user_service, product_service):
        self.user_service = user_service
        self.product_service = product_service

class SimpleMathFactory:
    def create_adder(self): return Adder()
    def create_subtractor(self): return Subtractor()

def add(a, b): return a + b
def subtract(a, b): return a - b
Mistake 3: Ignoring Thread Safety
class Counter:
    def __init__(self):
        self.count = 0
    def increment(self):
        self.count += 1  # Not atomic!

class Counter:
    def __init__(self):
        self.count = 0
        self._lock = threading.Lock()
    def increment(self):
        with self._lock:
            self.count += 1

